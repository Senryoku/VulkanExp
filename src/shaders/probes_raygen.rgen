#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_debug_printf : enable
#include "ProbeGrid.glsl"

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 6, set = 0, std140) uniform Block {
    ProbeGrid grid;
};

layout(binding = 7, set = 0) buffer ProbesBlock { uint Probes[]; };
layout(binding = 11, set = 0, r11f_g11f_b10f) uniform image2D color;
layout(binding = 12, set = 0, rg16f) uniform image2D depth;

layout(push_constant) uniform Push {
    mat4 randomOrientation;
    uint updateIndex;
} push;

#include "irradiance.glsl"
#include "rayPayload.glsl"

layout(location = 0) rayPayloadEXT rayPayload payload;

vec3 gridSpan = grid.extentMax - grid.extentMin;
vec3 gridCellSize = vec3(gridSpan.x / grid.resolution.x, gridSpan.y / grid.resolution.y, gridSpan.z / grid.resolution.z);

float MaxDistance = length(gridCellSize); // Fixme

uint MaxRefreshPeriod = 32; // In 'update attempt'

float max3 (vec3 v) {
  return max (max (v.x, v.y), v.z);
}

void main() {
    ivec3 index = ivec3(gl_LaunchIDEXT.xyz);
    index.y = int(push.updateIndex % grid.resolution.y);
    uint linearIndex = probeLinearIndex(index, grid);
    // Skip OFF probes
    if(Probes[linearIndex] == 0) return;
    // Reduced refresh rate
    if(Probes[linearIndex] > 1) { // Actually shoot rays only every 'Probes[linearIndex]' updates, staggered by x coordinate of the probe
        if(!(((push.updateIndex / grid.resolution.y) + gl_LaunchIDEXT.x) % Probes[linearIndex] == 0)) return;
    }
    
    payload.recursionDepth = 1; // Not sure about this one, but given the final resolution, I think it's safe to go for the cheaper option

	vec4 origin = vec4(probeIndexToWorldPosition(index, grid), 1);
    ivec2 probeUVOffset = probeIndexToColorUVOffset(index, grid);
    ivec2 probeDepthUVOffset = probeIndexToDepthUVOffset(index, grid);

    vec4 results[8 - 2][8 - 2]; // results[grid.colorRes - 2][grid.colorRes - 2] Should we declare them as constant, or just oversize the arrays?
    for(int i = 0; i < results.length(); ++i)
        for(int j = 0; j < results[0].length(); ++j)
            results[i][j] = vec4(0);
    vec3 depthResults[16 - 2][16 - 2];
    for(int i = 0; i < depthResults.length(); ++i)
        for(int j = 0; j < depthResults[0].length(); ++j)
            depthResults[i][j] = vec3(0);

	for(int i = 0; i < grid.raysPerProbe; ++i) {
		vec3 direction = mat3(push.randomOrientation) * sphericalFibonacci(i, grid.raysPerProbe);

		const float tmin = 0.1;
		const float tmax = 10000.0;

		payload.color = vec4(0.0);
        
        vec2 polar = cartesianToPolar(direction);
		payload.raydx = polarToCartesian(polar + vec2(0.1f, 0));
		payload.raydy = polarToCartesian(polar + vec2(0, 0.1f));
		traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin.xyz, tmin, direction, tmax, 0);
        
        float foundDepth = min(0.99f * payload.depth, MaxDistance);
        if(foundDepth < 0) foundDepth = MaxDistance;

        for(int x = 0; x < results.length(); ++x)
            for(int y = 0; y < results[0].length(); ++y) {
                // This could be pre-computed (Tried a naïve version: didn't gain much, but it's expected since it's so little compared to the ray tracing. Didn't feel like it was worth the obfuscation of a precomptuted table, at least for now.)
                vec3 texelDirection = octDecode(normalizeLocalTexelCoord(ivec2(x, y), grid.colorRes));
                float colorWeight = max(0.0, dot(texelDirection, direction));
                results[x][y] += vec4(colorWeight * payload.color.rgb, colorWeight);
	        }
        for(int x = 0; x < depthResults.length(); ++x)
            for(int y = 0; y < depthResults[0].length(); ++y) {
                vec3 texelDirection = octDecode(normalizeLocalTexelCoord(ivec2(x, y), grid.depthRes));
                float depthWeight = pow(max(0.0, dot(texelDirection, direction)), grid.depthSharpness);
                depthResults[x][y] += vec3(depthWeight * foundDepth, depthWeight * foundDepth * foundDepth, depthWeight);
            }
    }

    const float epsilon = 1e-3;

    float difference = 0;
    uint changedTexels = 0;
    
    for(int i = 0; i < grid.colorRes - 2; ++i)
        for(int j = 0; j < grid.colorRes - 2; ++j)
        if(results[i][j].w > epsilon) {
            ++changedTexels;
            results[i][j].xyz /= results[i][j].w;
            ivec2 uv = probeUVOffset + ivec2(1, 1) + ivec2(i, j); // Start of this probe + Border Skip + Local Texel
            vec3 prev = imageLoad(color, uv).xyz;
            difference += max3(abs(results[i][j].xyz - prev));
            results[i][j].xyz = grid.hysteresis * prev + (1.0f - grid.hysteresis) * results[i][j].xyz; // Simulating alpha blending
            imageStore(color, uv, vec4(results[i][j].xyz, 1.0));
        }

    // Reduce query frequency if changes are small
    difference /= changedTexels;
    if(difference < 0.1) 
        Probes[linearIndex] = min(Probes[linearIndex] * 2, MaxRefreshPeriod);
    else if(difference > 0.2)
        Probes[linearIndex] = max(1, Probes[linearIndex] / 2);
        
    for(int i = 0; i < grid.depthRes - 2; ++i)
        for(int j = 0; j < grid.depthRes - 2; ++j) 
            if(depthResults[i][j].z > epsilon) {
                depthResults[i][j].xy /= depthResults[i][j].z;
                vec2 prev = imageLoad(depth, probeDepthUVOffset + ivec2(1, 1) + ivec2(i, j)).xy;
                depthResults[i][j].xy = grid.hysteresis * prev + (1.0f - grid.hysteresis) * depthResults[i][j].xy; 
	            imageStore(depth, probeDepthUVOffset + ivec2(1, 1) + ivec2(i, j), vec4(depthResults[i][j].xy, 0.0, 0.0));
            }

    // Copy Border Texels (for correct texture filtering)
    // Corners
    int s = int(grid.colorRes) - 2;
    if(results[s - 1][s - 1].w > epsilon)
        imageStore(color, probeUVOffset + ivec2(                0, 0                ), vec4(results[s - 1][s - 1].xyz, 1.0));
    if(results[0]    [s - 1].w > epsilon)
        imageStore(color, probeUVOffset + ivec2(grid.colorRes - 1, 0                ), vec4(results[0]    [s - 1].xyz, 1.0));
    if(results[s - 1][0]    .w > epsilon)
        imageStore(color, probeUVOffset + ivec2(                0, grid.colorRes - 1), vec4(results[s - 1][0]    .xyz, 1.0));
    if(results[0]    [0]    .w > epsilon)
        imageStore(color, probeUVOffset + ivec2(grid.colorRes - 1, grid.colorRes - 1), vec4(results[0]    [0]    .xyz, 1.0));
    
     // Borders
    for(int i = 0; i < s; ++i)
        if(results[s - 1 - i][0].w > epsilon)
            imageStore(color, probeUVOffset + ivec2(            1 + i, 0                ), vec4(results[s - 1 - i][0]        .xyz, 1.0));
    for(int i = 0; i < s; ++i)
        if(results[s - 1 - i][s - 1].w > epsilon)
            imageStore(color, probeUVOffset + ivec2(            1 + i, grid.colorRes - 1), vec4(results[s - 1 - i][s - 1]    .xyz, 1.0));
    for(int i = 0; i < s; ++i)
        if(results[0]        [s - 1 - i].w > epsilon)
            imageStore(color, probeUVOffset + ivec2(                0, 1 + i            ), vec4(results[0]        [s - 1 - i].xyz, 1.0));
    for(int i = 0; i < s; ++i)
        if(results[s - 1]    [s - 1 - i].w > epsilon)
            imageStore(color, probeUVOffset + ivec2(grid.colorRes - 1, 1 + i            ), vec4(results[s - 1]    [s - 1 - i].xyz, 1.0));
    


    // Depth Borders Copy
    s = int(grid.depthRes) - 2;
    if(depthResults[s - 1][s - 1].z > epsilon)
        imageStore(depth, probeDepthUVOffset + ivec2(                0, 0                ), vec4(depthResults[s - 1][s - 1].xy, 0.0, 1.0));
    if(depthResults[0]    [s - 1].z > epsilon)
        imageStore(depth, probeDepthUVOffset + ivec2(grid.depthRes - 1, 0                ), vec4(depthResults[0]    [s - 1].xy, 0.0, 1.0));
    if(depthResults[s - 1][0]    .z > epsilon)
        imageStore(depth, probeDepthUVOffset + ivec2(                0, grid.depthRes - 1), vec4(depthResults[s - 1][0]    .xy, 0.0, 1.0));
    if(depthResults[0]    [0]    .z > epsilon)
        imageStore(depth, probeDepthUVOffset + ivec2(grid.depthRes - 1, grid.depthRes - 1), vec4(depthResults[0]    [0]    .xy, 0.0, 1.0));
    
     // Borders
    for(int i = 0; i < s; ++i)
        if(depthResults[s - 1 - i][0].z > epsilon)
            imageStore(depth, probeDepthUVOffset + ivec2(            1 + i, 0                ), vec4(depthResults[s - 1 - i][0]        .xy, 0.0, 1.0));
    for(int i = 0; i < s; ++i)
        if(depthResults[s - 1 - i][s - 1].z > epsilon)
            imageStore(depth, probeDepthUVOffset + ivec2(            1 + i, grid.depthRes - 1), vec4(depthResults[s - 1 - i][s - 1]    .xy, 0.0, 1.0));
    for(int i = 0; i < s; ++i)
        if(depthResults[0]        [s - 1 - i].z > epsilon)
            imageStore(depth, probeDepthUVOffset + ivec2(                0, 1 + i            ), vec4(depthResults[0]        [s - 1 - i].xy, 0.0, 1.0));
    for(int i = 0; i < s; ++i)
        if(depthResults[s - 1]    [s - 1 - i].z > epsilon)
            imageStore(depth, probeDepthUVOffset + ivec2(grid.depthRes - 1, 1 + i            ), vec4(depthResults[s - 1]    [s - 1 - i].xy, 0.0, 1.0));
    
}
