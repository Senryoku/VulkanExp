/* Copyright (c) 2019-2020, Sascha Willems
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 the "License";
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#version 460
#extension GL_EXT_ray_tracing : enable

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 6, set = 0, r11f_g11f_b10f) uniform image2D color;
layout(binding = 7, set = 0, rg16f) uniform image2D depth;
layout(binding = 8, set = 0, std140) uniform ProbeGrid {
    vec3 extentMin;
    float depthSharpness;
    vec3 extentMax;
    float hysteresis;
    ivec3 resolution;
    uint raysPerProbe;
    uint colorRes;
    uint depthRes;
    uint padding[2];
} grid;

layout(push_constant) uniform Push {
    mat3 randomOrientation;
} push;

struct rayPayload {
	vec3 raydx;
	vec3 raydy;

	vec3 color; // Result
	float depth;
};

layout(location = 0) rayPayloadEXT rayPayload payload;

const float pi = 3.1415926538f;
vec3 gridSpan = grid.extentMax - grid.extentMin;
vec3 gridCellSize = vec3(gridSpan.x / grid.resolution.x, gridSpan.y / grid.resolution.y, gridSpan.z / grid.resolution.z);


vec3 probeIndexToWorldPosition(uint index) {
	ivec3 pos = ivec3(index % grid.resolution.x, (index % (grid.resolution.x * grid.resolution.y)) / grid.resolution.z, index / (grid.resolution.x * grid.resolution.y));
	return pos * gridCellSize  + 0.5 * gridCellSize;
	// TODO: Add per-probe offset (< half of the size of a grid cell)
}

vec3 gridPositionToWorldPosition(uvec3 position) {
	return position * gridCellSize + 0.5 * gridCellSize;
}

/**  Generate a spherical fibonacci point

    http://lgdv.cs.fau.de/publications/publication/Pub.2015.tech.IMMD.IMMD9.spheri/

    To generate a nearly uniform point distribution on the unit sphere of size N, do
    for (float i = 0.0; i < N; i += 1.0) {
        float3 point = sphericalFibonacci(i,N);
    }

    The points go from z = +1 down to z = -1 in a spiral. To generate samples on the +z hemisphere,
    just stop before i > N/2.

*/
vec3 sphericalFibonacci(float i, float n) {
    const float PHI = sqrt(5) * 0.5 + 0.5;
#   define madfrac(A, B) ((A)*(B)-floor((A)*(B)))
    float phi = 2.0 * pi * madfrac(i, PHI - 1);
    float cosTheta = 1.0 - (2.0 * i + 1.0) * (1.0 / n);
    float sinTheta = sqrt(clamp(1.0 - cosTheta * cosTheta, 0, 1));

    return vec3(
        cos(phi) * sinTheta,
        sin(phi) * sinTheta,
        cosTheta);

#   undef madfrac
}

vec3 sphereToOctahedron(vec3 v) {
    vec3 octant = sign(v);
    // Scale the vector so |x| + |y| + |z| = 1 (surface of octahedron).
    float sum = dot(v, octant);        
    return v / sum;    
}

vec2 spherePointToOctohedralUV(vec3 direction) {
    vec3 octant = sign(direction);

    // Scale the vector so |x| + |y| + |z| = 1 (surface of octahedron).
    float sum = dot(direction, octant);        
    vec3 octahedron = direction / sum;    

    // "Untuck" the corners using the same reflection across the diagonal as before.
    // (A reflection is its own inverse transformation).
    if(octahedron.z < 0) {
        vec3 absolute = abs(octahedron);
        octahedron.xy = octant.xy
                      * vec2(1.0f - absolute.y, 1.0f - absolute.x);
    }

    return octahedron.xy * 0.5f + 0.5f;
}

// Assuming v is normalized
vec2 cartesianToPolar(vec3 v) {
    vec2 r = vec2(
        acos(v.z),
        atan(v.y/v.x)
    );
    if(v.x < 0) v.y += pi;
    return r;
}

// Assuming a unit vector
vec3 polarToCartesian(vec2 v) {
    return vec3(cos(v.y) * sin(v.x), sin(v.y) * sin(v.x), cos(v.x));
}

float signNotZero(in float k) {
    return (k >= 0.0) ? 1.0 : -1.0;
}

vec2 signNotZero(in vec2 v) {
    return vec2(signNotZero(v.x), signNotZero(v.y));
}

/** Assumes that v is a unit vector. The result is an octahedral vector on the [-1, +1] square. */
vec2 octEncode(in vec3 v) {
    float l1norm = abs(v.x) + abs(v.y) + abs(v.z);
    vec2 result = v.xy * (1.0 / l1norm);
    if (v.z < 0.0) 
        result = (1.0 - abs(result.yx)) * signNotZero(result.xy);
    return result;
}

/** Returns a unit vector. Argument o is an octahedral vector packed via octEncode,
    on the [-1, +1] square*/
vec3 octDecode(vec2 o) {
    vec3 v = vec3(o.x, o.y, 1.0 - abs(o.x) - abs(o.y));
    if (v.z < 0.0)
        v.xy = (1.0 - abs(v.yx)) * signNotZero(v.xy);
    return normalize(v);
}

// Compute normalized oct coord, mapping top left of top left pixel to (-1,-1)
vec2 normalizedOctCoord(ivec2 fragCoord, uint res) {
    vec2 octFragCoord = ivec2((fragCoord.x - 2) % res, (fragCoord.y - 2) % res);
    // Add back the half pixel to get pixel center normalized coordinates
    return (vec2(octFragCoord) + vec2(0.5f))  *(2.0f / float(res - 2)) - vec2(1.0f, 1.0f);
}

void main() 
{
	vec4 origin = vec4(gridPositionToWorldPosition(gl_LaunchIDEXT.xyz), 1);
    ivec2 probeUVOffset = ivec2(grid.colorRes * gl_LaunchIDEXT.xy);
    ivec2 probeDepthUVOffset = ivec2(grid.depthRes * gl_LaunchIDEXT.xy);

    vec4 results[8][8]; // results[grid.colorRes][grid.colorRes] Should we declare them as constant, or just oversize the arrays?
    for(int i = 0; i < grid.colorRes; ++i)
        for(int j = 0; j < grid.colorRes; ++j)
            results[i][j] = vec4(0);
    vec3 depthResults[16][16];
    for(int i = 0; i < grid.depthRes; ++i)
        for(int j = 0; j < grid.depthRes; ++j)
            depthResults[i][j] = vec3(0);

	for(int i = 0; i < grid.raysPerProbe; ++i) {
		vec4 direction = vec4(push.randomOrientation * sphericalFibonacci(i, grid.raysPerProbe), 1.0f);

		float tmin = 0.001;
		float tmax = 100000.0;

		payload.color = vec3(1.0, 0.0, 0.0);

        vec2 polar = cartesianToPolar(direction.xyz);
		payload.raydx = polarToCartesian(polar + vec2(0.1f, 0));//normalize(direction.xyz + vec3(0.1, 0, 0));
		payload.raydy = polarToCartesian(polar + vec2(0, 0.1f));//normalize(direction.xyz + vec3(0, 0.1, 0));
        vec2 uv = spherePointToOctohedralUV(direction.xyz);
        ivec2 colorUV = ivec2((grid.colorRes - 2) * uv);
        ivec2 depthUV = ivec2((grid.depthRes - 2) * uv);
		traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin.xyz, tmin, direction.xyz, tmax, 0);
        
        vec3 texelDirection = octDecode(normalizedOctCoord(ivec2(uv * grid.colorRes), grid.colorRes));
        float colorWeight = max(0.0, dot(texelDirection, direction.xyz));
        float depthWeight = pow(colorWeight, grid.depthSharpness);
        results[colorUV.x][colorUV.y] += vec4(colorWeight * payload.color, colorWeight);
        payload.depth /= length(gridCellSize);
        depthResults[depthUV.x][depthUV.y] += vec3(depthWeight * payload.depth, depthWeight * payload.depth * payload.depth, depthWeight);
	}
    
    for(int i = 0; i < grid.colorRes; ++i)
        for(int j = 0; j < grid.colorRes; ++j)
        if(results[i][j].w > 1e-6) {
            results[i][j].xyz /= results[i][j].w;
            vec3 prev = (1.0f - grid.hysteresis) * imageLoad(color, probeUVOffset + ivec2(i, j)).xyz; // Simulating alpha blending
            imageStore(color, probeUVOffset + ivec2(i, j), vec4(prev + grid.hysteresis * results[i][j].xyz, 1.0));
        }
        
    for(int i = 0; i < grid.depthRes; ++i)
        for(int j = 0; j < grid.depthRes; ++j) 
            if(depthResults[i][j].z > 1e-6) {
                depthResults[i][j].xy /= depthResults[i][j].z;
                vec2 prev = (1.0f - grid.hysteresis) * imageLoad(depth, probeDepthUVOffset + ivec2(i, j)).xy;
	            imageStore(depth, probeDepthUVOffset + ivec2(i, j), vec4(prev + grid.hysteresis * depthResults[i][j].xy, 0.0, 0.0));
            }
}
