/* Copyright (c) 2019-2020, Sascha Willems
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 the "License";
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#version 460
#extension GL_EXT_ray_tracing : enable

#include "irradiance.glsl"

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 6, set = 0, std140) uniform Block {
    ProbeGrid grid;
};
layout(binding = 10, set = 0, r11f_g11f_b10f) uniform image2D color;
layout(binding = 11, set = 0, rg16f) uniform image2D depth;

layout(push_constant) uniform Push {
    mat3 randomOrientation;
} push;

#include "rayPayload.glsl"

layout(location = 0) rayPayloadEXT rayPayload payload;

vec3 gridSpan = grid.extentMax - grid.extentMin;
vec3 gridCellSize = vec3(gridSpan.x / grid.resolution.x, gridSpan.y / grid.resolution.y, gridSpan.z / grid.resolution.z);

float MaxDistance = length(gridCellSize); // Fixme

void main() 
{
    payload.recursionDepth = 1; // Not sure about this one, but given the final resolution, I think it's safe to go for the cheaper option

	vec4 origin = vec4(probeIndexToWorldPosition(ivec3(gl_LaunchIDEXT.xyz), grid), 1);
    ivec2 probeUVOffset = probeIndexToColorUVOffset(ivec3(gl_LaunchIDEXT.xyz), grid);
    ivec2 probeDepthUVOffset = probeIndexToDepthUVOffset(ivec3(gl_LaunchIDEXT.xyz), grid);

    vec4 results[8 - 2][8 - 2]; // results[grid.colorRes - 2][grid.colorRes - 2] Should we declare them as constant, or just oversize the arrays?
    for(int i = 0; i < results.length(); ++i)
        for(int j = 0; j < results[0].length(); ++j)
            results[i][j] = vec4(0);
    vec3 depthResults[16 - 2][16 - 2];
    for(int i = 0; i < depthResults.length(); ++i)
        for(int j = 0; j < depthResults[0].length(); ++j)
            depthResults[i][j] = vec3(0);

	for(int i = 0; i < grid.raysPerProbe; ++i) {
		vec3 direction = push.randomOrientation * sphericalFibonacci(i, grid.raysPerProbe);

		const float tmin = 0.1;
		const float tmax = 10000.0;

		payload.color = vec4(0.0);
        
        vec2 polar = cartesianToPolar(direction);
		payload.raydx = polarToCartesian(polar + vec2(0.1f, 0));
		payload.raydy = polarToCartesian(polar + vec2(0, 0.1f));
		traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin.xyz, tmin, direction, tmax, 0);
        
        if(payload.depth < 0) payload.depth = MaxDistance; //continue;

        for(int x = 0; x < results.length(); ++x)
            for(int y = 0; y < results[0].length(); ++y) {
                // This could be pre-computed (Tried a naïve version: didn't gain much, but it's expected since it's so little compared to the ray tracing. Didn't feel like it was worth the obfuscation of a precomptuted table, at least for now.)
                vec3 texelDirection = octDecode(normalizeLocalTexelCoord(ivec2(x, y), grid.colorRes));
                float colorWeight = max(0.0, dot(texelDirection, direction));
                results[x][y] += vec4(colorWeight * payload.color.rgb, colorWeight);
	        }
        for(int x = 0; x < depthResults.length(); ++x)
            for(int y = 0; y < depthResults[0].length(); ++y) {
                vec3 texelDirection = octDecode(normalizeLocalTexelCoord(ivec2(x, y), grid.depthRes));
                float depthWeight = pow(max(0.0, dot(texelDirection, direction)), grid.depthSharpness);
                float foundDepth = min(0.99f * payload.depth, MaxDistance);
                depthResults[x][y] += vec3(depthWeight * foundDepth, depthWeight * foundDepth * foundDepth, depthWeight);
            }
    }

    const float epsilon = 1e-3;
    
    for(int i = 0; i < grid.colorRes - 2; ++i)
        for(int j = 0; j < grid.colorRes - 2; ++j)
        if(results[i][j].w > epsilon) {
            results[i][j].xyz /= results[i][j].w;
            vec3 prev = imageLoad(color, probeUVOffset + ivec2(1, 1) + ivec2(i, j)).xyz; // Simulating alpha blending
            results[i][j].xyz = grid.hysteresis * prev + (1.0f - grid.hysteresis) * results[i][j].xyz;
            imageStore(color, probeUVOffset
                + ivec2(1, 1) // Skip Border
                + ivec2(i, j), vec4(results[i][j].xyz, 1.0));
        }
        
    for(int i = 0; i < grid.depthRes - 2; ++i)
        for(int j = 0; j < grid.depthRes - 2; ++j) 
            if(depthResults[i][j].z > epsilon) {
                depthResults[i][j].xy /= depthResults[i][j].z;
                vec2 prev = imageLoad(depth, probeDepthUVOffset + ivec2(1, 1) + ivec2(i, j)).xy;
                depthResults[i][j].xy = grid.hysteresis * prev + (1.0f - grid.hysteresis) * depthResults[i][j].xy; 
	            imageStore(depth, probeDepthUVOffset + ivec2(1, 1) + ivec2(i, j), vec4(depthResults[i][j].xy, 0.0, 0.0));
            }

    // Copy Border Texels (for correct texture filtering)
    // Corners
    int s = int(grid.colorRes) - 2;
    if(results[s - 1][s - 1].w > epsilon)
        imageStore(color, probeUVOffset + ivec2(                0, 0                ), vec4(results[s - 1][s - 1].xyz, 1.0));
    if(results[0]    [s - 1].w > epsilon)
        imageStore(color, probeUVOffset + ivec2(grid.colorRes - 1, 0                ), vec4(results[0]    [s - 1].xyz, 1.0));
    if(results[s - 1][0]    .w > epsilon)
        imageStore(color, probeUVOffset + ivec2(                0, grid.colorRes - 1), vec4(results[s - 1][0]    .xyz, 1.0));
    if(results[0]    [0]    .w > epsilon)
        imageStore(color, probeUVOffset + ivec2(grid.colorRes - 1, grid.colorRes - 1), vec4(results[0]    [0]    .xyz, 1.0));
    
     // Borders
    for(int i = 0; i < s; ++i) {
        if(results[s - 1 - i][0].w > epsilon)
            imageStore(color, probeUVOffset + ivec2(            1 + i, 0                ), vec4(results[s - 1 - i][0]        .xyz, 1.0));
        if(results[s - 1 - i][s - 1].w > epsilon)
            imageStore(color, probeUVOffset + ivec2(            1 + i, grid.colorRes - 1), vec4(results[s - 1 - i][s - 1]    .xyz, 1.0));
        if(results[0]        [s - 1 - i].w > epsilon)
            imageStore(color, probeUVOffset + ivec2(                0, 1 + i            ), vec4(results[0]        [s - 1 - i].xyz, 1.0));
        if(results[s - 1]    [s - 1 - i].w > epsilon)
            imageStore(color, probeUVOffset + ivec2(grid.colorRes - 1, 1 + i            ), vec4(results[s - 1]    [s - 1 - i].xyz, 1.0));
    }


    // Depth Borders Copy
    s = int(grid.depthRes) - 2;
    if(depthResults[s - 1][s - 1].z > epsilon)
        imageStore(depth, probeDepthUVOffset + ivec2(                0, 0                ), vec4(depthResults[s - 1][s - 1].xy, 0.0, 1.0));
    if(depthResults[0]    [s - 1].z > epsilon)
        imageStore(depth, probeDepthUVOffset + ivec2(grid.depthRes - 1, 0                ), vec4(depthResults[0]    [s - 1].xy, 0.0, 1.0));
    if(depthResults[s - 1][0]    .z > epsilon)
        imageStore(depth, probeDepthUVOffset + ivec2(                0, grid.depthRes - 1), vec4(depthResults[s - 1][0]    .xy, 0.0, 1.0));
    if(depthResults[0]    [0]    .z > epsilon)
        imageStore(depth, probeDepthUVOffset + ivec2(grid.depthRes - 1, grid.depthRes - 1), vec4(depthResults[0]    [0]    .xy, 0.0, 1.0));
    
     // Borders
    for(int i = 0; i < s; ++i) {
        if(depthResults[s - 1 - i][0].z > epsilon)
            imageStore(depth, probeDepthUVOffset + ivec2(            1 + i, 0                ), vec4(depthResults[s - 1 - i][0]        .xy, 0.0, 1.0));
        if(depthResults[s - 1 - i][s - 1].z > epsilon)
            imageStore(depth, probeDepthUVOffset + ivec2(            1 + i, grid.depthRes - 1), vec4(depthResults[s - 1 - i][s - 1]    .xy, 0.0, 1.0));
        if(depthResults[0]        [s - 1 - i].z > epsilon)
            imageStore(depth, probeDepthUVOffset + ivec2(                0, 1 + i            ), vec4(depthResults[0]        [s - 1 - i].xy, 0.0, 1.0));
        if(depthResults[s - 1]    [s - 1 - i].z > epsilon)
            imageStore(depth, probeDepthUVOffset + ivec2(grid.depthRes - 1, 1 + i            ), vec4(depthResults[s - 1]    [s - 1 - i].xy, 0.0, 1.0));
    }
}
