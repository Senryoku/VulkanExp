/* Copyright (c) 2019-2020, Sascha Willems
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 the "License";
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#version 460
#extension GL_EXT_ray_tracing : enable

#include "irradiance.glsl"

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 6, set = 0, r11f_g11f_b10f) uniform image2D color;
layout(binding = 7, set = 0, rg16f) uniform image2D depth;
layout(binding = 8, set = 0, std140) uniform Block {
    ProbeGrid grid;
};

layout(push_constant) uniform Push {
    mat3 randomOrientation;
} push;

struct rayPayload {
	vec3 raydx;
	vec3 raydy;

	vec3 color; // Result
	float depth;
};

layout(location = 0) rayPayloadEXT rayPayload payload;

vec3 gridSpan = grid.extentMax - grid.extentMin;
vec3 gridCellSize = vec3(gridSpan.x / grid.resolution.x, gridSpan.y / grid.resolution.y, gridSpan.z / grid.resolution.z);

float MaxDistance = 1000.0; // Fixme

void main() 
{
	vec4 origin = vec4(probeIndexToWorldPosition(ivec3(gl_LaunchIDEXT.xyz), grid), 1);
    ivec2 probeUVOffset = probeIndexToColorUVOffset(ivec3(gl_LaunchIDEXT.xyz), grid);
    ivec2 probeDepthUVOffset = probeIndexToDepthUVOffset(ivec3(gl_LaunchIDEXT.xyz), grid);

    vec4 results[8 - 2][8 - 2]; // results[grid.colorRes][grid.colorRes] Should we declare them as constant, or just oversize the arrays?
    for(int i = 0; i < results.length(); ++i)
        for(int j = 0; j < results[i].length(); ++j)
            results[i][j] = vec4(0);
    vec3 depthResults[16 - 2][16 - 2];
    for(int i = 0; i < depthResults.length(); ++i)
        for(int j = 0; j < depthResults[i].length(); ++j)
            depthResults[i][j] = vec3(0);

	for(int i = 0; i < grid.raysPerProbe; ++i) {
		vec4 direction = vec4(push.randomOrientation * sphericalFibonacci(i, grid.raysPerProbe), 1.0f);

		float tmin = 0.001;
		float tmax = 100000.0;

		payload.color = vec3(1.0, 0.0, 0.0);

        vec2 polar = cartesianToPolar(direction.xyz);
		payload.raydx = polarToCartesian(polar + vec2(0.1f, 0));//normalize(direction.xyz + vec3(0.1, 0, 0));
		payload.raydy = polarToCartesian(polar + vec2(0, 0.1f));//normalize(direction.xyz + vec3(0, 0.1, 0));
        vec2 uv = spherePointToOctohedralUV(direction.xyz); // [0, 1.0]
        ivec2 colorUV = clamp(ivec2((grid.colorRes - 2) * uv), 0, int(grid.colorRes - 3)); // [0, grid.colorRes - 2[
        ivec2 depthUV = clamp(ivec2((grid.depthRes - 2) * uv), 0, int(grid.depthRes - 3));
		traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin.xyz, tmin, direction.xyz, tmax, 0);
        
        vec3 texelDirection = normalize(sphereToOctahedron(direction.xyz)); // octDecode(normalizedOctCoord(ivec2(uv * grid.colorRes), grid.colorRes));
        float colorWeight = max(0.0, dot(texelDirection, direction.xyz));
        float depthWeight = pow(colorWeight, grid.depthSharpness);
        results[colorUV.x][colorUV.y] += vec4(colorWeight * payload.color, colorWeight);
        float depth = min(0.99f * payload.depth, MaxDistance);
        if(depth < 0) depth = MaxDistance;
        depthResults[depthUV.x][depthUV.y] += vec3(depthWeight * depth, depthWeight * depth * depth, depthWeight);
	}
    
    for(int i = 0; i < grid.colorRes - 2; ++i)
        for(int j = 0; j < grid.colorRes - 2; ++j)
        if(results[i][j].w > 1e-6) {
            results[i][j].xyz /= results[i][j].w;
            vec3 prev = imageLoad(color, probeUVOffset + ivec2(1, 1) + ivec2(i, j)).xyz; // Simulating alpha blending
            results[i][j].xyz = (1.0f - grid.hysteresis) * prev + grid.hysteresis * results[i][j].xyz;
            imageStore(color, probeUVOffset
                + ivec2(1, 1) // Skip Border
                + ivec2(i, j), vec4(results[i][j].xyz, 1.0));
        }
        
    for(int i = 0; i < grid.depthRes - 2; ++i)
        for(int j = 0; j < grid.depthRes - 2; ++j) 
            if(depthResults[i][j].z > 1e-6) {
                depthResults[i][j].xy /= depthResults[i][j].z;
                vec2 prev = imageLoad(depth, probeDepthUVOffset + ivec2(1, 1) + ivec2(i, j)).xy;
                depthResults[i][j].xy = (1.0f - grid.hysteresis) * prev + grid.hysteresis * depthResults[i][j].xy; 
	            imageStore(depth, probeDepthUVOffset + ivec2(1, 1) + ivec2(i, j), vec4(depthResults[i][j].xy, 0.0, 0.0));
            }

    // Copy Border Texels (for correct texture filtering)
    // Corners
    int s = int(grid.colorRes) - 2;
    if(results[s - 1][s - 1].w > 1e-6)
        imageStore(color, probeUVOffset + ivec2(0,                 0),                 vec4(results[s - 1][s - 1].xyz, 1.0));
    if(results[0]    [s - 1].w > 1e-6)
        imageStore(color, probeUVOffset + ivec2(grid.colorRes - 1, 0),                 vec4(results[0]    [s - 1].xyz, 1.0));
    if(results[s - 1][0]    .w > 1e-6)
        imageStore(color, probeUVOffset + ivec2(0,                 grid.colorRes - 1), vec4(results[s - 1][0]    .xyz, 1.0));
    if(results[0]    [0]    .w > 1e-6)
        imageStore(color, probeUVOffset + ivec2(grid.colorRes - 1, grid.colorRes - 1), vec4(results[0]    [0]    .xyz, 1.0));
    
     // Borders
    for(int i = 0; i < s; ++i) {
        if(results[s - 1 - i][0].w > 1e-6)
            imageStore(color, probeUVOffset + ivec2(1 + i,             0                ), vec4(results[s - 1 - i][0]        .xyz, 1.0));
        if(results[s - 1 - i][s - 1].w > 1e-6)
            imageStore(color, probeUVOffset + ivec2(1 + i,             grid.colorRes - 1), vec4(results[s - 1 - i][s - 1]    .xyz, 1.0));
        if(results[0][s - 1 - i].w > 1e-6)
            imageStore(color, probeUVOffset + ivec2(0,                 1 + i            ), vec4(results[0]        [s - 1 - i].xyz, 1.0));
        if(results[s - 1][s - 1 - i].w > 1e-6)
            imageStore(color, probeUVOffset + ivec2(grid.colorRes - 1, 1 + i            ), vec4(results[s - 1]    [s - 1 - i].xyz, 1.0));
    }


    // Depth Borders Copy
    s = int(grid.depthRes) - 2;
    if(depthResults[s - 1][s - 1].z > 1e-6)
        imageStore(depth, probeDepthUVOffset + ivec2(0,                 0),                 vec4(depthResults[s - 1][s - 1].xyz, 1.0));
    if(depthResults[0]    [s - 1].z > 1e-6)
        imageStore(depth, probeDepthUVOffset + ivec2(grid.depthRes - 1, 0),                 vec4(depthResults[0]    [s - 1].xyz, 1.0));
    if(depthResults[s - 1][0]    .z > 1e-6)
        imageStore(depth, probeDepthUVOffset + ivec2(0,                 grid.depthRes - 1), vec4(depthResults[s - 1][0]    .xyz, 1.0));
    if(depthResults[0]    [0]    .z > 1e-6)
        imageStore(depth, probeDepthUVOffset + ivec2(grid.depthRes - 1, grid.depthRes - 1), vec4(depthResults[0]    [0]    .xyz, 1.0));
    
     // Borders
    for(int i = 0; i < s; ++i) {
        if(depthResults[s - 1 - i][0].z > 1e-6)
            imageStore(depth, probeDepthUVOffset + ivec2(1 + i,             0                ), vec4(depthResults[s - 1 - i][0]        .xyz, 1.0));
        if(depthResults[s - 1 - i][s - 1].z > 1e-6)
            imageStore(depth, probeDepthUVOffset + ivec2(1 + i,             grid.depthRes - 1), vec4(depthResults[s - 1 - i][s - 1]    .xyz, 1.0));
        if(depthResults[0][s - 1 - i].z > 1e-6)
            imageStore(depth, probeDepthUVOffset + ivec2(0,                 1 + i            ), vec4(depthResults[0]        [s - 1 - i].xyz, 1.0));
        if(depthResults[s - 1][s - 1 - i].z > 1e-6)
            imageStore(depth, probeDepthUVOffset + ivec2(grid.depthRes - 1, 1 + i            ), vec4(depthResults[s - 1]    [s - 1 - i].xyz, 1.0));
    }
}
